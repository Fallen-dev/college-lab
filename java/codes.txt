EXP-3 (1) FORK
#icnlude<stdio.h>
#include<sys/types.h>
#include<unistd.h>
int main() {
    fork();
    fork();
    printf("Hello World!");
    return 0;
}

EXP-3 (2) POSIX THREAD
#icnlude<stdio.h>
#include<sys/types.h>
#include<unistd.h>

void posixThread() {
    int x=1, pid, ppid;

    if (fork() == 0) {
        pid = getpid();
        printf("Child pid=%d, x=%d\n", pid, ++x);
    } else {
        ppid = getpid();
        printf("Parent pid=%d, x=%d\n", ppid, ++x);
    }
}

int main() {
    posixThread();
    return 0;
}

EXP-4 (1) ROUND ROBIN
#include<stdio.h>
int main(){
  int i,limit,total=0,x,c=0,t_quantum;
  int w=0,t=0,a[10],b[10],temp[10];
  float awt,att;
  printf("\nEnter the total number of Process: ");
  scanf("%d",&limit);
  x=limit;
  for(i=0;i<limit;i++){
    printf("Enter detail of Process[%d]\n",i+1);
    printf("Arrival time: ");
    scanf("%d",&a[i]);
    printf("Burst time: ");
    scanf("%d",&b[i]);
    temp[i]=b[i];
  }
  printf("\nEnter Time Quantum: ");
  scanf("%d",&t_quantum);
  printf("\nProcess Id\t  Burst Time\t  Turn Around Time\t  Waiting Time\n");
  for(total=0,i=0;x!=0;){
    if(temp[i]<=t_quantum && temp[i]>0){
      total=total+temp[i];
      temp[i]=0;
      c=1;
    }
    else if(temp[i]>0){
      temp[i]=temp[i]-t_quantum;
      total=total+t_quantum;
    }
    else if(temp[i]==0 && c==1){
      x--;
      printf("\nProcess[%d]\t\t %d\t\t %d\t\t %d",i+1,b[i],total-a[i],total-a[i]-b[i]);
      w=w+total-a[i]-b[i];
      t=t+total-a[i];
      c=0;
    }
    else if(i==limit-1){
      i=0;
    }
    else if(a[i+1]<=total){
      i++;
    }
    else{
      i=0;
    }
  }
  awt=w*1.0/limit;
  att=t*1.0/limit;
  printf("\nAverage Waiting Time: %f",awt);
  printf("\nAverage Turn Around Time: %f\n",att);
  return 0;
}
EXP-4 (2) priority queue
#include<stdio.h>
#include<stdio.h>
#include<stdlib.h>

typedef struct {
    int pno;
    int pri;
    intpri;
    int btime;
    int wtime;
}sp;

int main(){
    int i,j,n;
    int tbm=0,totwtime=0,totttime=0;
    sp *p,t;
    printf("\n PRIORITY SCHEDULING.\n");printf("\n enter the no of process...\n");
    scanf("%d",&n);
    p=(sp*)malloc(sizeof(sp));

    printf("enter the burst time and priority:\n");
    for(i=0;i<n;i++) {
        printf("process%d:”,i+1);
        scanf("%d%d",&p[i].btime,&p[i].pri);
        p[i].pno=i+1;
        p[i].wtime=0;
    }
    for(i=0;i<n-1;i++)
        for(j=i+1;j<n;j++) {
            if(p[i].pri>p[j].pri){
                t=p[i];p[i]=p[j];p[j]=t;
            }
        }
    printf("\n process\tbursttime\twaiting time\tturnaround time\n");
    for(i=0;i<n;i++) {
        totwtime+=p[i].wtime=tbm;
        tbm+=p[i].btime;
        printf("\n%d\t\t%d",p[i].pno,p[i].btime);
        printf("\t\t%d\t\t%d",p[i].wtime,p[i].wtime+p[i].btime);
    }
    totttime=tbm+totwtime;
    printf("\n total waiting time:%d",totwtime);
    printf("\n average waiting time:%f",(float)totwtime/n);
    printf("\n total turnaround time:%d",totttime);
    printf("\n avg turnaround time:%f",(float)totttime/n);
}

EXP-5 (1) PEODUCER CONSUMER
#include<stdio.h>
#include<stdlib.h>
int mutex=1,full=0,empty=3,x=0;
int main()
{
	int n;
	void producer();
	void consumer();
	int wait(int);
	int signal(int);

	printf("\n1.producer\n2.consumer\n3.Exit");
	while(1)
	     {
		printf("\n Enter the choice: ");
		scanf("%d",&n);
		switch(n)
		{
			case 1:
				if((mutex==1) && (empty!=0))
					producer();
				else
					printf("Buffer is full.");
				break;

			case 2: if((mutex==1) && (full!=0))
					consumer();
				else
					printf("Buffer is empty");
				break;

			case 3:
				exit(0);
				break;
		}

	     }

	     return 0;
}
int wait(int s)
{
	return (--s);

}
int signal(int s)
{
	return (++s);
}
void producer()
{
	mutex=wait(mutex);
	full=signal(full);
	empty=wait(empty);
	x++;
		printf("\n Producer produces the item %d",x);
	mutex=signal(mutex);
}
void consumer()
{
	mutex=wait(mutex);
	full=wait(full);
	empty=signal(empty);
		printf("\n Consumer consumes the item %d",x);
	x--;
	mutex=signal(mutex);
}

EXP-5 (2) dining philosophers
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>
#define NUM_PHILOSOPHERS 5
#define NUM_CHOPSTICKS 5

void dine(int n);
pthread_t philosopher[NUM_PHILOSOPHERS];
pthread_mutex_t chopsticks[NUM_CHOPSTICKS];

main(){
	int i, status_message;
	void *msg;

	for(i = 1; i <= NUM_CHOPSTICKS; i++){
		status_message = pthread_mutex_init(&chopsticks[i], NULL);
		if(status_message == -1){
			printf("\n Mutex initialization failed");
			exit(1);
		}
	}
	for(i = 1; i <= NUM_PHILOSOPHERS; i++){
		status_message = pthread_create(&philosopher[i], NULL, (void *)dine, (int *)i);
		if(status_message != 0){
			printf("\nThread creation error.\n");
			exit(1);
		}
	}
	for(i = 1; i <= NUM_PHILOSOPHERS; i++){
		status_message = pthread_join(philosopher[i], &msg);
		if(status_message != 0){
			printf("Thread join failed.");
			exit(1);
		}
	}
	for(i = 1; i<= NUM_PHILOSOPHERS; i++){
		status_message = pthread_mutex_destroy(&chopsticks[i]);
		if(status_message != 0){
			printf("\nMutex destroyed.\n");
			exit(1);
		}
	}
	return 0;
}
void dine(int n){
	printf("Philosopher %d is thinking.", n);
	pthread_mutex_lock(&chopsticks[n]);
	pthread_mutex_lock(&chopsticks[(n + 1) % NUM_CHOPSTICKS]);
	printf("\nPhilosopher %d is eating", n);
	pthread_mutex_unlock(&chopsticks[n]);
	pthread_mutex_unlock(&chopsticks[(n + 1) % NUM_CHOPSTICKS]);
	printf("\nPhilosopher %d has finished eating ", n);
}

EXP-6 (1) BANKER'S ALGO
#include<stdio.h>
int max[100][100];
int alloc[100][100];
int need[100][100];
int avail[100];
int n,r;
int input()
{
int i,j;
printf("\nEnter the no of process:\t");
scanf("%d",&n);
printf("\nEnter the no of resource instances:\t");
scanf("%d",&r);
printf("\nEnter the MAX Matrix:\n");
for(i=0;i<n;i++)
{
for(j=0;j<r;j++)
{
scanf("%d",&max[i][j]);
}
}
printf("Enter the allocation matrix:\n");
for(i=0;i<n;i++)
{
for(j=0;j<r;j++){
scanf("%d",&alloc[i][j]);
}
}
printf("Enter the available resources:\n");
for(j=0;j<r;j++){
scanf("%d",&avail[j]);
}
}
void show()
{
int i,j;
printf("\nProcess\tAllocation\tMax\tAvailable\t");
for(i=0;i<n;i++){
printf("\nP%d\t",i+1);
for(j=0;j<r;j++)
{
printf("%d ",alloc[i][j]);
}
printf("\t");
for(j=0;j<r;j++)
{
printf("%d ",max[i][j]);
}
printf("\t");
if(i==0)
{
for(j=0;j<r;j++)
printf("%d ",avail[j]);
}
}
}
void cal()
{
int finish[100],temp,need[100][100],flag=1,k,c1=0;
int safe[100];
int i,j;
for(i=0;i<n;i++)
{
finish[i]=0;
}

for(i=0;i<n;i++)
{
for(j=0;j<r;j++)

{
need[i][j]=max[i][j]-alloc[i][j];
}
}
printf("\n");
while(flag)
{
flag=0;
for(i=0;i<n;i++)
{
int c=0;
for(j=0;j<r;j++)
{
if((finish[i]==0)&&(need[i][j]<=avail[j]))
{
c++;
if(c==r)
{
for(k=0;k<r;k++)
{
avail[k]+=alloc[i][j];
finish[i]=1;
flag=1;
}
printf("P%d->",i);
if(finish[i]==1)
{
i=n;
}
}
}
}
}
}
for(i=0;i<n;i++)
{
if(finish[i]==1)
{
c1++;
}
else
{
printf("P%d->",i);
}

}
if(c1==n)
{
printf("\n The system is in safe state");
}
else
{
printf("\n Process are in dead lock");
printf("\n System is in unsafe state");
}
}
int main(){
int i,j;
printf("********** Banker's Algo ************\n");
input();
show();
cal();
return 0;
}

EXP-6 (2) deadlock detect
#include<stdio.h>
int max[100][100];
int alloc[100][100];
int need[100][100];
int avail[100];
int n,r;
void input(){
int i,j;
printf("Enter the no of Processes\t");
scanf("%d",&n);
printf("Enter the no of resource instances\t");
scanf("%d",&r);
printf("Enter the Max Matrix\n");
for(i=0;i<n;i++){
for(j=0;j<r;j++){
scanf("%d",&max[i][j]);}}
printf("Enter the Allocation Matrix\n");
for(i=0;i<n;i++){
for(j=0;j<r;j++){
scanf("%d",&alloc[i][j]);}}
printf("Enter the available Resource\n");
for(j=0;j<r;j++){
scanf("%d",&avail[j]);}
}
void show(){
int i,j;
printf("Process\t Allocation \t Max \t Available\t");
for(i=0;i<n;i++){
printf("\nP%d\t ",i+1);
for(j=0;j<r;j++){
printf("%d ",alloc[i][j]);}
printf("\t");
for(j=0;j<r;j++){
printf("%d ",max[i][j]);}
printf("\t");
if(i==0){
for(j=0;j<r;j++){
printf("%d ",avail[j]);}
}
}
}
void calcu(){
int finish[100],temp,need[100][100],flag=1,k,c1=0;
int dead[100];
int safe[100];
int i,j;
for(i=0;i<n;i++){
finish[i]=0;}
for(i=0;i<n;i++){
for(j=0;j<r;j++){
need[i][j]=max[i][j]-alloc[i][j];}}
while(flag){
flag=0;
for(i=0;i<n;i++){
int c=0;
for(j=0;j<r;j++){
if((finish[i]==0) &&(need[i][j]<=avail[j])){
c++;
if(c==r){
for(k=0;k<r;k++){
avail[k]+=alloc[i][j];
finish[i]=1;
flag=1;}
if(finish[i]==1){
i=n;}
}
}
}
}
}
j=0;
flag=0;
for(i=0;i<n;i++){
if(finish[i]==0){
dead[j]=i;
j++;
flag=1;
}
}
if(flag==1){
printf("\n\nSystem is Deadlock and the Deadlock process are\n");
for(i=0;i<n;i++){
printf("P%d\t",dead[i]);}
}
else{
printf("\nNo Deadlock Occur");
}
}

int main(){
printf("*************** Deadlock Detection Algo ****************\n");
input();
show();
calcu();
return 0;
}

EXP-7 (1) FIRST/BEST/WORST FIT
#include<stdio.h>
void firstFit(int blockSize[], int m, int processSize[], int n)
{
	int i, j;
	int allocation[n];
	for(i = 0; i < n; i++)
	{
		allocation[i] = -1;
	}
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < m; j++)
		{
			if (blockSize[j] >= processSize[i])
			{
				allocation[i] = j;
				blockSize[j] -= processSize[i];
				break;
			}
		}
	}
	printf("\nProcess No.\tProcess Size\tBlock no.\n");
	for (i = 0; i < n; i++)
	{
		printf(" %i\t\t\t", i+1);
		printf("%i\t\t\t\t", processSize[i]);
		if (allocation[i] != -1)
			printf("%i", allocation[i] + 1);
		else
			printf("Not Allocated");
		printf("\n");
	}
}

void bestFit(int blockSize[], int blocks, int processSize[], int proccesses)
{
    int allocation[proccesses];
    int occupied[blocks];
    for(int i = 0; i < proccesses; i++){
        allocation[i] = -1;
    }
    for(int i = 0; i < blocks; i++){
        occupied[i] = 0;
    }
    for (int i = 0; i < proccesses; i++)
    {

        int indexPlaced = -1;
        for (int j = 0; j < blocks; j++) {
            if (blockSize[j] >= processSize[i] && !occupied[j])
            {
                if (indexPlaced == -1)
                    indexPlaced = j;
                else if (blockSize[j] < blockSize[indexPlaced])
                    indexPlaced = j;
            }
        }
        if (indexPlaced != -1)
        {
            allocation[i] = indexPlaced;
            occupied[indexPlaced] = 1;
        }
    }
    printf("\nProcess No.\tProcess Size\tBlock no.\n");
    for (int i = 0; i < proccesses; i++)
    {
        printf("%d \t\t\t %d \t\t\t", i+1, processSize[i]);
        if (allocation[i] != -1)
            printf("%d\n",allocation[i] + 1);
        else
            printf("Not Allocated\n");
    }
}

void worstFit(int blockSize[], int blocks, int processSize[], int processes)
{
    int allocation[processes];
    int occupied[blocks];
    for(int i = 0; i < processes; i++){
        allocation[i] = -1;
    }

    for(int i = 0; i < blocks; i++){
        occupied[i] = 0;
    }
    for (int i=0; i < processes; i++)
    {
	int indexPlaced = -1;
	for(int j = 0; j < blocks; j++)
	{
	    if(blockSize[j] >= processSize[i] && !occupied[j])
            {
                if (indexPlaced == -1)
                    indexPlaced = j;
                else if (blockSize[indexPlaced] < blockSize[j])
                    indexPlaced = j;
            }
        }
        if (indexPlaced != -1)
        {
            allocation[i] = indexPlaced;
            occupied[indexPlaced] = 1;
            blockSize[indexPlaced] -= processSize[i];
        }
    }
    printf("\nProcess No.\tProcess Size\tBlock no.\n");
    for (int i = 0; i < processes; i++)
    {
        printf("%d \t\t\t %d \t\t\t", i+1, processSize[i]);
        if (allocation[i] != -1)
            printf("%d\n",allocation[i] + 1);
        else
            printf("Not Allocated\n");
    }
}

int main()
{
	int m, i;
	int n;
	int z;
	int blockSize[100];
	int processSize[100];
	printf("\n Enter the number of memory blocks:");
	scanf("%d", &m);
        printf("\n Enter the %d number of memory blocks:\n", m);
        for(i=0; i<m ; i++)
        	scanf("%d", &blockSize[i]);
    	printf("\n Enter the number of process blocks:");
	scanf("%d", &n);

        printf("\n Enter the %d number of process block:\n", n);
        for(i=0; i<n ; i++)
        	scanf("%d", &processSize[i]);
	while(1)
	{
		printf("\nEnter your choice");
		printf("\n1. First Fit\n2. Best-Fit\n3.Worst-Fit\n4.Exit\n");
		scanf("%d",&z);
		switch(z)
		{
			case 1:
				firstFit(blockSize, m, processSize, n);
				break;

			case 2:
				bestFit(blockSize, m, processSize, n);
				break;

			case 3:
				worstFit(blockSize, m, processSize, n);
				break;

			case 4:
				return 0;


			default:
				printf("\n Invalid Input\n");
				break;
		}
	}
	return 0 ;
}


EXP-7 (2) STUDENT INFO SEQUENTIAL FILE
#include<stdio.h>

typedef struct{
	int roll;
	char name[25];
	int m1,m2,m3;
}std;

std s;

void display(FILE *fp)
{
	rewind(fp);
	while(fread(&s, sizeof(s), 1,fp))
	{
		printf("%d\t%s\t%d\t%d\t%d\n",s.roll,s.name, s.m1,s.m2,s.m3);
	}
}

int search(FILE *fp, int roll_key)
{
	rewind(fp);
	while(fread(&s,sizeof(s),1,fp))
		if(s.roll == roll_key)return 1;
	return 0;
}

int main()
{
	int i,n,roll_key,ch;
	FILE *fp;
	printf("How many Records ?");
	scanf("%d", &n);
	fp = fopen("stud.dat","w");
	for(i = 0;i<n;i++)
	{
		printf("Read the Info fo Student: %d (roll,name(one word)), marks1,marks2,marks3)\n",i+1);
		scanf("%d%s%d%d%d",&s.roll,s.name,&s.m1, &s.m2,&s.m3);
		fwrite(&s,sizeof(s),1,fp);
	}
	fclose(fp);
	fp = fopen("stud.dat","r");
	do
	{
		printf("Press 1 - Display\t 2 - Search\t 3 - Exit \t Enter your choice?");
		scanf("%d",&ch);
		switch(ch)
		{
			case 1:
				printf("\n Student Records int the File \n");
				printf("Roll \t Name\tmarks 1 Marks2 Marks 3\n");
				display(fp);
				break;

			case 2:
				printf(" Read the roll number of the student to be searched ?");
				scanf("%d",&roll_key);
				if(search(fp,roll_key))
				{
					printf("Success ! Record found in the file\n");
					printf("%d\t%s\t%d\t%d\t%d\n",s.roll,s.name, s.m1,s.m2,s.m3);
				}
				else
				{
					printf(" Failure !! Record with roll %d not found\n",roll_key);
				}
				break;

			case 3:
				printf(" Exit!! Press a key. . .");
				return 0;
				break;

			default:
				printf(" Invalid Option!!! Try again!!!\n");
				break;

		}
	}while(ch != 3);
	fclose(fp);
	return 0;
}
